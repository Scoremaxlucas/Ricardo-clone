datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  title     String? // Anrede (Herr, Frau, etc.)
  firstName String? // Vorname
  lastName  String? // Nachname
  password  String?
  image     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // E-Mail Bestätigung
  emailVerified                 Boolean   @default(false)
  emailVerifiedAt               DateTime?
  emailVerificationToken        String?
  emailVerificationTokenExpires DateTime?

  // Public profile fields
  nickname       String?
  bio            String?
  specialization String?

  // Profil-Daten (nur nötig zum Handeln)
  profileComplete Boolean   @default(false)
  dateOfBirth     DateTime?
  nationality     String?
  phone           String?
  phoneVerified   Boolean   @default(false)

  // Adresse
  street       String?
  streetNumber String?
  postalCode   String?
  city         String?
  country      String?

  // Rechnungsadresse (optional)
  billingStreet       String?
  billingStreetNumber String?
  billingPostalCode   String?
  billingCity         String?
  billingCountry      String?

  // Lieferadresse (abweichend, optional)
  deliveryStreet       String?
  deliveryStreetNumber String?
  deliveryPostalCode   String?
  deliveryCity         String?
  deliveryCountry      String?

  // Zahlungsmittel (JSON String: array von payment methods)
  // Format: [{type: "twint", phone: "..."}, {type: "bank", iban: "...", accountHolderFirstName: "...", accountHolderLastName: "...", bank: "..."}, {type: "creditcard", ...}]
  paymentMethods String? // JSON array

  // Ausweiskopie (Base64 String)
  idDocument      String? // Base64 encoded document (for Passport or single file)
  idDocumentPage1 String? // Base64 encoded Seite 1 der Identitätskarte
  idDocumentPage2 String? // Base64 encoded Seite 2 der Identitätskarte
  idDocumentType  String? // "ID" or "Passport"

  // Firmeninfo
  companyName String?

  // Kontotyp & Verifizierung
  accountType            String? // privat, geschäftlich
  verified               Boolean   @default(false)
  verificationLevel      String? // basic, verified, premium
  verifiedAt             DateTime? // Wann wurde der User verifiziert
  verificationStatus     String?   @default("pending") // pending, approved, rejected
  verificationReviewedAt DateTime? // Wann wurde die Verifizierung geprüft
  verificationReviewedBy String? // ID des Admin-Users der geprüft hat

  // Admin & Moderation
  isAdmin       Boolean   @default(false)
  isBlocked     Boolean   @default(false)
  blockedAt     DateTime?
  blockedBy     String? // ID des Admin-Users der blockiert hat (oder "system" für automatische Sperre)
  blockedReason String? // "unpaid_invoice", "agb_violation", "admin_action", etc.
  warningCount  Int       @default(0)
  lastWarnedAt  DateTime?

  // Zahlungs-Tracking (Performance-Optimierung)
  hasUnpaidInvoices     Boolean   @default(false) // Cache-Flag für Performance
  lastInvoiceReminderAt DateTime? // Letzte Erinnerung

  // Relations
  accounts         Account[]
  sessions         Session[]
  watches          Watch[]
  bids             Bid[]
  purchases        Purchase[]
  sales            Sale[]
  salePurchases    Sale[]         @relation("SaleBuyer")
  reviews          Review[]
  receivedReviews  Review[]       @relation("ReviewedUser")
  favorites        Favorite[]
  messages         Message[]      @relation("MessageSender")
  receivedMessages Message[]      @relation("MessageReceiver")
  invoices         Invoice[]
  priceOffers      PriceOffer[]
  notifications    Notification[]
  searchSubscriptions SearchSubscription[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Watch {
  id              String    @id @default(cuid())
  articleNumber   Int?      @unique // Benutzerfreundliche Artikelnummer (z.B. 12345678)
  title           String
  description     String?
  brand           String
  model           String
  year            Int?
  condition       String
  material        String?
  movement        String?
  caseSize        Float?
  caseDiameter    Float?
  price           Float
  buyNowPrice     Float?
  isAuction       Boolean   @default(false)
  auctionStart    DateTime? // Optional: Starttermin für das Angebot
  auctionEnd      DateTime?
  auctionDuration Int? // Dauer in Tagen (max. 30)
  autoRenew       Boolean   @default(false) // Automatische Verlängerung
  lastBidAt       DateTime? // Zeitpunkt des letzten Gebots (für Auto-Verlängerung)
  images          String
  video           String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Additional fields for detailed form
  lastRevision        DateTime?
  accuracy            String?
  fullset             Boolean   @default(false)
  allLinks            Boolean   @default(false)
  box                 Boolean   @default(false)
  papers              Boolean   @default(false)
  warranty            String?
  warrantyMonths      Int?
  warrantyYears       Int?
  warrantyNote        String?
  warrantyDescription String?
  referenceNumber     String?
  shippingMethod      String? // JSON Array: ['pickup', 'b-post', 'a-post']
  boosters            String? // JSON Array: selected boosters ['top', 'homepage', 'highlighted', etc.]

  // Relations
  sellerId     String
  seller       User            @relation(fields: [sellerId], references: [id])
  bids         Bid[]
  purchases    Purchase[]
  sales        Sale[]
  favorites    Favorite[]
  messages     Message[]
  categories   WatchCategory[]
  invoiceItems InvoiceItem[]
  priceOffers  PriceOffer[]

  @@map("watches")
}

model Bid {
  id        String   @id @default(cuid())
  amount    Float
  createdAt DateTime @default(now())

  watchId String
  watch   Watch  @relation(fields: [watchId], references: [id])
  userId  String
  user    User   @relation(fields: [userId], references: [id])

  @@map("bids")
}

model Purchase {
  id             String  @id @default(cuid())
  price          Float? // Verkaufspreis zum Zeitpunkt des Kaufs (optional für Migration)
  shippingMethod String? // Gewählte Lieferart: 'pickup', 'b-post', 'a-post'

  // Status-Felder für Ricardo-ähnlichen Prozess
  status             String    @default("pending") // pending, item_received, payment_confirmed, completed
  itemReceived       Boolean   @default(false) // Käufer bestätigt Erhalt des Artikels
  itemReceivedAt     DateTime? // Zeitpunkt der Erhalt-Bestätigung
  paymentConfirmed   Boolean   @default(false) // Verkäufer bestätigt Zahlung (ersetzt paid)
  paymentConfirmedAt DateTime? // Zeitpunkt der Zahlungsbestätigung (ersetzt paidAt)

  // Kontaktfrist-Tracking (7-Tage-Regel nach Ricardo)
  contactDeadline       DateTime // Frist für Kontaktaufnahme (7 Tage nach Purchase, wird im Code gesetzt)
  sellerContactedAt     DateTime? // Zeitpunkt der ersten Kontaktaufnahme durch Verkäufer
  buyerContactedAt      DateTime? // Zeitpunkt der ersten Kontaktaufnahme durch Käufer
  contactWarningSentAt  DateTime? // Zeitpunkt der letzten Warnung (nach 5 Tagen)
  contactDeadlineMissed Boolean   @default(false) // Flag ob Frist überschritten wurde

  // Zahlungsfrist-Tracking (14-Tage-Regel nach Ricardo)
  paymentDeadline       DateTime? // Frist für Zahlung (14 Tage nach Kontaktaufnahme)
  paymentReminderSentAt DateTime? // Zeitpunkt der letzten Zahlungserinnerung
  paymentDeadlineMissed Boolean   @default(false) // Flag ob Zahlungsfrist überschritten wurde

  // Versand-Tracking
  trackingNumber        String? // Tracking-Nummer für Versand
  trackingProvider      String? // Versanddienstleister (post, dhl, etc.)
  shippedAt             DateTime? // Zeitpunkt des Versands
  estimatedDeliveryDate DateTime? // Geschätztes Lieferdatum

  // Dispute-System
  disputeOpenedAt     DateTime? // Zeitpunkt der Dispute-Eröffnung
  disputeReason       String? // Grund für Dispute (item_not_received, item_damaged, etc.)
  disputeDescription  String? // Detaillierte Beschreibung des Disputes
  disputeStatus       String? // pending, resolved, closed
  disputeResolvedAt   DateTime? // Zeitpunkt der Dispute-Lösung
  disputeResolvedBy   String? // ID des Admin-Users der gelöst hat

  // Status-Historie
  statusHistory String? // JSON Array: [{status, timestamp, changedBy, reason}]

  // Legacy-Felder (für Rückwärtskompatibilität)
  paid   Boolean   @default(false) // @deprecated: Verwende paymentConfirmed
  paidAt DateTime? // @deprecated: Verwende paymentConfirmedAt

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  watchId String
  watch   Watch  @relation(fields: [watchId], references: [id])
  buyerId String
  buyer   User   @relation(fields: [buyerId], references: [id])

  reviews     Review[] // Bewertungen für diesen Kauf
  priceOffers PriceOffer[] // Preisvorschläge die zu diesem Purchase geführt haben

  @@map("purchases")
}

model Sale {
  id        String   @id @default(cuid())
  price     Float? // Verkaufspreis zum Zeitpunkt des Verkaufs (optional für Migration)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  watchId  String
  watch    Watch   @relation(fields: [watchId], references: [id])
  sellerId String
  seller   User    @relation(fields: [sellerId], references: [id])
  buyerId  String? // Käufer (optional, falls vorhanden)
  buyer    User?   @relation("SaleBuyer", fields: [buyerId], references: [id])

  reviews Review[] // Bewertungen für diesen Verkauf

  @@map("sales")
}

model Payment {
  id        String   @id @default(cuid())
  amount    Float
  status    String
  createdAt DateTime @default(now())

  @@map("payments")
}

model Review {
  id        String   @id @default(cuid())
  rating    String // positive, neutral, negative
  comment   String?
  createdAt DateTime @default(now())

  // Relations
  reviewerId     String
  reviewer       User   @relation(fields: [reviewerId], references: [id])
  reviewedUserId String
  reviewedUser   User   @relation("ReviewedUser", fields: [reviewedUserId], references: [id])

  // Optional: Verknüpfung zu Purchase/Sale (für Bewertungen nach Kauf/Verkauf)
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])
  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id])

  @@unique([purchaseId, reviewerId]) // Ein Reviewer kann nur einmal pro Purchase bewerten
  @@unique([saleId, reviewerId]) // Ein Reviewer kann nur einmal pro Sale bewerten
  @@map("reviews")
}

model Favorite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  watchId String
  watch   Watch  @relation(fields: [watchId], references: [id])
  userId  String
  user    User   @relation(fields: [userId], references: [id])

  @@unique([watchId, userId])
  @@map("favorites")
}

model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  watches WatchCategory[]

  @@map("categories")
}

model WatchCategory {
  id         String @id @default(cuid())
  watchId    String
  categoryId String

  watch    Watch    @relation(fields: [watchId], references: [id])
  category Category @relation(fields: [categoryId], references: [id])

  @@unique([watchId, categoryId])
  @@map("watch_categories")
}

model Message {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  read      Boolean  @default(false)
  isPublic  Boolean  @default(false)

  watchId String
  watch   Watch  @relation(fields: [watchId], references: [id])

  senderId String
  sender   User   @relation("MessageSender", fields: [senderId], references: [id])

  receiverId String
  receiver   User   @relation("MessageReceiver", fields: [receiverId], references: [id])

  @@map("messages")
}

model Invoice {
  id            String @id @default(cuid())
  invoiceNumber String @unique // Eindeutige Rechnungsnummer (z.B. REV-2024-001)

  // Verkäufer
  sellerId String
  seller   User   @relation(fields: [sellerId], references: [id])

  // Verkaufsinformationen
  saleId String? // Reference to Purchase

  // Gebührenberechnung
  subtotal  Float // Summe ohne MwSt (Booster + 10% vom Verkauf)
  vatRate   Float @default(0.081) // MwSt-Satz (8.1%)
  vatAmount Float // MwSt-Betrag
  total     Float // Total zu zahlen (Subtotal + MwSt)

  // Status
  status  String    @default("pending") // pending, paid, overdue, cancelled, blocked
  paidAt  DateTime?
  dueDate DateTime

  // Zahlungsmethoden
  paymentMethod      String? // twint, creditcard, qr-transfer, bank, paypal
  paymentReference   String? // Referenznummer / Transaction ID
  paymentConfirmedAt DateTime? // Wann wurde Zahlung bestätigt?

  // Score-Max QR-Code
  qrCode String? // Score-Max QR-Code String

  // Mahnprozess-Tracking (Ricardo-Style)
  paymentRequestSentAt DateTime? // Tag 14: Erste Zahlungsaufforderung
  firstReminderSentAt  DateTime? // Tag 30: Erste Erinnerung
  secondReminderSentAt DateTime? // Tag 44: Zweite Erinnerung + Mahnspesen
  finalReminderSentAt  DateTime? // Tag 58: Letzte Erinnerung + Konto-Sperre
  reminderCount        Int       @default(0) // Anzahl gesendeter Erinnerungen
  lateFeeAdded         Boolean   @default(false) // Mahnspesen hinzugefügt?
  lateFeeAmount        Float     @default(0) // Betrag der Mahnspesen (CHF 10.–)

  // Konto-Sperre
  accountBlockedAt     DateTime? // Wann wurde Konto gesperrt?
  accountBlockedReason String? // Grund für Sperre

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items InvoiceItem[]

  @@map("invoices")
}

model InvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id])

  watchId String?
  watch   Watch?  @relation(fields: [watchId], references: [id])

  description String // Beschreibung (z.B. "Plattformgebühr 10%", "Booster: Top-Anzeige")
  quantity    Int    @default(1)
  price       Float // Einzelpreis
  total       Float // Gesamtpreis (quantity * price)

  createdAt DateTime @default(now())

  @@map("invoice_items")
}

model BoosterPrice {
  id          String  @id @default(cuid())
  code        String  @unique // Eindeutiger Code: 'top', 'homepage', 'highlighted', etc.
  name        String // Anzeigename: "Top-Anzeige", "Homepage-Feature", etc.
  description String? // Beschreibung der Funktion
  price       Float // Preis in CHF
  isActive    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("booster_prices")
}

model PriceOffer {
  id        String    @id @default(cuid())
  amount    Float
  message   String?
  status    String    @default("pending") // pending, accepted, rejected, expired
  expiresAt DateTime? // Ablaufdatum (48 Stunden nach Erstellung)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  watchId String
  watch   Watch  @relation(fields: [watchId], references: [id], onDelete: Cascade)
  buyerId String
  buyer   User   @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  // Verknüpfung zum Purchase (wenn akzeptiert)
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id], onDelete: SetNull)

  @@map("price_offers")
}

model Notification {
  id        String    @id @default(cuid())
  type      String // NOTIFICATION_TYPE enum
  title     String
  message   String
  link      String?
  isRead    Boolean   @default(false) // Bestehende Spalte
  readAt    DateTime? // Bestehende Spalte
  createdAt DateTime  @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional: Verknüpfungen zu anderen Entitäten
  watchId      String?
  bidId        String? // Bestehende Spalte
  questionId   String? // Bestehende Spalte
  priceOfferId String?
  purchaseId   String?

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

model SearchSubscription {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Suchkriterien
  searchTerm String? // Freitext-Suche
  brand      String? // Marke
  model      String? // Modell
  categoryId String? // Kategorie
  subcategoryId String? // Unterkategorie
  
  // Preisbereich
  minPrice   Float?
  maxPrice   Float?
  
  // Weitere Filter
  condition  String? // Zustand
  yearFrom   Int? // Jahr von
  yearTo     Int? // Jahr bis
  
  // Status
  isActive   Boolean  @default(true)
  
  // Tracking
  matchesFound Int    @default(0) // Anzahl gefundener Matches
  lastMatchAt  DateTime? // Letzter Match
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, isActive])
  @@index([isActive])
  @@map("search_subscriptions")
}
