generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                            String               @id @default(cuid())
  email                         String               @unique
  name                          String?
  title                         String?
  firstName                     String?
  lastName                      String?
  password                      String?
  image                         String?
  createdAt                     DateTime             @default(now())
  updatedAt                     DateTime             @updatedAt
  emailVerified                 Boolean              @default(false)
  emailVerifiedAt               DateTime?
  emailVerificationToken        String?
  emailVerificationTokenExpires DateTime?
  nickname                      String?
  bio                           String?
  specialization                String?
  profileComplete               Boolean              @default(false)
  dateOfBirth                   DateTime?
  nationality                   String?
  phone                         String?
  phoneVerified                 Boolean              @default(false)
  street                        String?
  streetNumber                  String?
  postalCode                    String?
  city                          String?
  country                       String?
  billingStreet                 String?
  billingStreetNumber           String?
  billingPostalCode             String?
  billingCity                   String?
  billingCountry                String?
  deliveryStreet                String?
  deliveryStreetNumber          String?
  deliveryPostalCode            String?
  deliveryCity                  String?
  deliveryCountry               String?
  paymentMethods                String?
  idDocument                    String?
  idDocumentPage1               String?
  idDocumentPage2               String?
  idDocumentType                String?
  companyName                   String?
  accountType                   String?
  verified                      Boolean              @default(false)
  verificationLevel             String?
  verifiedAt                    DateTime?
  verificationStatus            String?              @default("pending")
  verificationReviewedAt        DateTime?
  verificationReviewedBy        String?
  isAdmin                       Boolean              @default(false)
  isBlocked                     Boolean              @default(false)
  blockedAt                     DateTime?
  blockedBy                     String?
  blockedReason                 String?
  warningCount                  Int                  @default(0)
  lastWarnedAt                  DateTime?
  hasUnpaidInvoices             Boolean              @default(false)
  lastInvoiceReminderAt         DateTime?
  accounts                      Account[]
  bids                          Bid[]
  favorites                     Favorite[]
  invoices                      Invoice[]
  receivedMessages              Message[]            @relation("MessageReceiver")
  messages                      Message[]            @relation("MessageSender")
  notifications                 Notification[]
  priceOffers                   PriceOffer[]
  purchases                     Purchase[]
  receivedReviews               Review[]             @relation("ReviewedUser")
  reviews                       Review[]
  salePurchases                 Sale[]               @relation("SaleBuyer")
  sales                         Sale[]
  searchSubscriptions           SearchSubscription[]
  sessions                      Session[]
  watches                       Watch[]
  conversations                 Conversation[]
  reportsMade                   Report[]             @relation("ReportedBy")
  reportsReviewed               Report[]             @relation("ReviewedBy")
  userReportsMade               UserReport[]         @relation("UserReportedBy")
  userReportsReviewed           UserReport[]         @relation("UserReportReviewedBy")
  userReportsReceived           UserReport[]         @relation("ReportedUser")
  adminNotes                    AdminNote[]
  moderationHistory             ModerationHistory[]
  maxBids                       MaxBid[]
  userAdminNotes                UserAdminNote[]      @relation("UserAdminNoteAdmin")
  userAdminNotesForUser         UserAdminNote[]      @relation("UserAdminNoteUser")
  userActivities                UserActivity[]
  searchQueries                 SearchQuery[]
  userPreferences               UserPreferences?
  collections                   Collection[]
  auctionViewers                AuctionViewer[]
  stories                       Story[]
  browsingHistory               BrowsingHistory[]
  userBadges                    UserBadge[]
  userStreaks                   UserStreak?
  rewards                       Reward[]
  aiConversations               AIConversation[]
  aiSearchResults               AISearchResult[]
  pricingHistoryChanges         PricingHistory[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Watch {
  id                  String              @id @default(cuid())
  articleNumber       Int?                @unique
  title               String
  description         String?
  brand               String
  model               String
  year                Int?
  condition           String
  material            String?
  movement            String?
  caseSize            Float?
  caseDiameter        Float?
  price               Float
  buyNowPrice         Float?
  isAuction           Boolean             @default(false)
  auctionStart        DateTime?
  auctionEnd          DateTime?
  auctionDuration     Int?
  autoRenew           Boolean             @default(false)
  lastBidAt           DateTime?
  images              String
  video               String?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  lastRevision        DateTime?
  accuracy            String?
  fullset             Boolean             @default(false)
  allLinks            Boolean             @default(false)
  box                 Boolean             @default(false)
  papers              Boolean             @default(false)
  warranty            String?
  warrantyMonths      Int?
  warrantyYears       Int?
  warrantyNote        String?
  warrantyDescription String?
  referenceNumber     String?
  shippingMethod      String?
  boosters            String?
  sellerId            String
  moderationStatus    String?             @default("pending") // 'pending', 'approved', 'rejected', 'reviewing'
  moderatedBy         String?
  moderatedAt         DateTime?
  moderationNotes     String?
  bids                Bid[]
  favorites           Favorite[]
  invoiceItems        InvoiceItem[]
  messages            Message[]
  priceOffers         PriceOffer[]
  purchases           Purchase[]
  sales               Sale[]
  categories          WatchCategory[]
  seller              User                @relation(fields: [sellerId], references: [id])
  reports             Report[]
  adminNotes          AdminNote[]
  moderationHistory   ModerationHistory[]
  views               WatchView[]
  maxBids             MaxBid[]
  productStats        ProductStats?
  collectionItems     CollectionItem[]
  auctionViewers      AuctionViewer[]
  stories             Story[]
  browsingHistory     BrowsingHistory[]
  aiSearchResults     AISearchResult[]

  @@index([moderationStatus])
  @@index([createdAt])
  @@index([sellerId]) // KRITISCH: Für schnelle Abfragen nach sellerId
  @@index([sellerId, createdAt]) // OPTIMIERT: Für Sortierung nach createdAt bei sellerId-Filter
  @@index([title]) // PERFORMANCE: Für schnelle Textsuche
  @@index([brand]) // PERFORMANCE: Für schnelle Brand-Filterung
  @@index([price]) // PERFORMANCE: Für schnelle Preis-Sortierung
  @@index([articleNumber]) // PERFORMANCE: Für schnelle Artikelnummer-Lookups
  @@index([auctionEnd]) // PERFORMANCE: Für schnelle Auktion-Filterung
  @@index([title, brand]) // PERFORMANCE: Composite Index für kombinierte Suche
  @@map("watches")
}

model Bid {
  id        String   @id @default(cuid())
  amount    Float
  createdAt DateTime @default(now())
  watchId   String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@index([watchId]) // OPTIMIERT: Für schnelle Bid-Abfragen
  @@index([watchId, amount]) // OPTIMIERT: Für Sortierung nach amount bei watchId-Filter
  @@map("bids")
}

// Automatisches Gebot (Maximalgebot)
model MaxBid {
  id         String   @id @default(cuid())
  watchId    String
  userId     String
  maxAmount  Float // Maximales Gebot
  currentBid Float? // Aktuelles Gebot (wird automatisch erhöht)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, userId]) // Ein MaxBid pro User pro Watch
  @@index([watchId])
  @@index([userId])
  @@map("max_bids")
}

model Purchase {
  id                             String       @id @default(cuid())
  price                          Float?
  shippingMethod                 String?
  status                         String       @default("pending")
  itemReceived                   Boolean      @default(false)
  itemReceivedAt                 DateTime?
  paymentConfirmed               Boolean      @default(false)
  paymentConfirmedAt             DateTime?
  contactDeadline                DateTime
  sellerContactedAt              DateTime?
  buyerContactedAt               DateTime?
  contactWarningSentAt           DateTime?
  contactDeadlineMissed          Boolean      @default(false)
  paymentDeadline                DateTime?
  paymentReminderSentAt          DateTime?
  paymentReminderCount           Int          @default(0)
  paymentDeadlineMissed          Boolean      @default(false)
  trackingNumber                 String?
  trackingProvider               String?
  shippedAt                      DateTime?
  estimatedDeliveryDate          DateTime?
  disputeOpenedAt                DateTime?
  disputeReason                  String?
  disputeDescription             String?
  disputeStatus                  String?
  disputeResolvedAt              DateTime?
  disputeResolvedBy              String?
  cancellationRequestedAt        DateTime?
  cancellationRequestStatus      String?
  cancellationRequestReason      String?
  cancellationRequestDescription String?
  cancellationRequestResolvedAt  DateTime?
  cancellationRequestResolvedBy  String?
  statusHistory                  String?
  paid                           Boolean      @default(false)
  paidAt                         DateTime?
  createdAt                      DateTime     @default(now())
  updatedAt                      DateTime     @updatedAt
  watchId                        String
  buyerId                        String
  priceOffers                    PriceOffer[]
  buyer                          User         @relation(fields: [buyerId], references: [id])
  watch                          Watch        @relation(fields: [watchId], references: [id])
  reviews                        Review[]

  @@index([watchId]) // OPTIMIERT: Für schnelle Purchase-Abfragen
  @@index([watchId, status]) // OPTIMIERT: Für Filterung nach Status bei watchId-Filter
  @@map("purchases")
}

model Sale {
  id        String   @id @default(cuid())
  price     Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  watchId   String
  sellerId  String
  buyerId   String?
  reviews   Review[]
  buyer     User?    @relation("SaleBuyer", fields: [buyerId], references: [id])
  seller    User     @relation(fields: [sellerId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@map("sales")
}

model Payment {
  id        String   @id @default(cuid())
  amount    Float
  status    String
  createdAt DateTime @default(now())

  @@map("payments")
}

model Review {
  id             String    @id @default(cuid())
  rating         String
  comment        String?
  createdAt      DateTime  @default(now())
  reviewerId     String
  reviewedUserId String
  purchaseId     String?
  saleId         String?
  sale           Sale?     @relation(fields: [saleId], references: [id])
  purchase       Purchase? @relation(fields: [purchaseId], references: [id])
  reviewedUser   User      @relation("ReviewedUser", fields: [reviewedUserId], references: [id])
  reviewer       User      @relation(fields: [reviewerId], references: [id])

  @@unique([purchaseId, reviewerId])
  @@unique([saleId, reviewerId])
  @@map("reviews")
}

model Favorite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  watchId   String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, userId])
  @@map("favorites")
}

model Category {
  id        String          @id @default(cuid())
  name      String          @unique
  slug      String          @unique
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  watches   WatchCategory[]

  @@map("categories")
}

model WatchCategory {
  id         String   @id @default(cuid())
  watchId    String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, categoryId])
  @@map("watch_categories")
}

model Message {
  id         String   @id @default(cuid())
  content    String
  createdAt  DateTime @default(now())
  read       Boolean  @default(false)
  isPublic   Boolean  @default(false)
  watchId    String
  senderId   String
  receiverId String
  receiver   User     @relation("MessageReceiver", fields: [receiverId], references: [id])
  sender     User     @relation("MessageSender", fields: [senderId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@map("messages")
}

model Invoice {
  id                   String        @id @default(cuid())
  invoiceNumber        String        @unique
  sellerId             String
  saleId               String?
  subtotal             Float
  vatRate              Float         @default(0.081)
  vatAmount            Float
  total                Float
  status               String        @default("pending")
  paidAt               DateTime?
  dueDate              DateTime
  paymentMethod        String?
  paymentReference     String?
  paymentConfirmedAt   DateTime?
  qrCode               String?
  paymentRequestSentAt DateTime?
  firstReminderSentAt  DateTime?
  secondReminderSentAt DateTime?
  finalReminderSentAt  DateTime?
  reminderCount        Int           @default(0)
  lateFeeAdded         Boolean       @default(false)
  lateFeeAmount        Float         @default(0)
  accountBlockedAt     DateTime?
  accountBlockedReason String?
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  refundedAt           DateTime?
  originalInvoiceId    String? // Verknüpfung zur ursprünglichen Rechnung bei Korrektur-Rechnungen
  originalInvoice      Invoice?      @relation("InvoiceCorrection", fields: [originalInvoiceId], references: [id])
  correctionInvoices   Invoice[]     @relation("InvoiceCorrection")
  items                InvoiceItem[]
  seller               User          @relation(fields: [sellerId], references: [id])

  @@map("invoices")
}

model InvoiceItem {
  id          String   @id @default(cuid())
  invoiceId   String
  watchId     String?
  description String
  quantity    Int      @default(1)
  price       Float
  total       Float
  createdAt   DateTime @default(now())
  watch       Watch?   @relation(fields: [watchId], references: [id])
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])

  @@map("invoice_items")
}

model BoosterPrice {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  price       Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("booster_prices")
}

model PriceOffer {
  id         String    @id @default(cuid())
  amount     Float
  message    String?
  status     String    @default("pending")
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  watchId    String
  buyerId    String
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])
  buyer      User      @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  watch      Watch     @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@map("price_offers")
}

model Notification {
  id           String    @id @default(cuid())
  type         String
  title        String
  message      String
  link         String?
  isRead       Boolean   @default(false)
  readAt       DateTime?
  createdAt    DateTime  @default(now())
  userId       String
  watchId      String?
  bidId        String?
  questionId   String?
  priceOfferId String?
  purchaseId   String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

model SearchSubscription {
  id            String    @id @default(cuid())
  userId        String
  searchTerm    String?
  brand         String?
  model         String?
  categoryId    String?
  subcategoryId String?
  minPrice      Float?
  maxPrice      Float?
  condition     String?
  yearFrom      Int?
  yearTo        Int?
  isActive      Boolean   @default(true)
  matchesFound  Int       @default(0)
  lastMatchAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([isActive])
  @@map("search_subscriptions")
}

model Conversation {
  id        String                @id @default(cuid())
  userId    String?
  context   String? // JSON string mit Kontext (productId, etc.)
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  messages  ConversationMessage[]
  user      User?                 @relation(fields: [userId], references: [id])

  @@map("conversations")
}

model ConversationMessage {
  id             String       @id @default(cuid())
  conversationId String
  role           String // 'user' | 'assistant' | 'system'
  content        String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("conversation_messages")
}

model ContactRequest {
  id         String    @id @default(cuid())
  category   String // 'technical', 'account', 'payment', 'safety', 'general', 'feedback', 'other'
  email      String
  subject    String
  message    String
  status     String    @default("pending") // 'pending', 'in_progress', 'resolved', 'closed'
  resolvedAt DateTime?
  resolvedBy String?
  notes      String? // Admin-Notizen
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([status])
  @@index([createdAt])
  @@map("contact_requests")
}

// Melde-System für Angebote
model Report {
  id          String    @id @default(cuid())
  watchId     String
  reportedBy  String // User-ID des Meldenden
  reason      String // 'spam', 'fraud', 'wrong_category', 'inappropriate', 'duplicate', 'other'
  description String? // Zusätzliche Beschreibung
  status      String    @default("pending") // 'pending', 'reviewing', 'resolved', 'dismissed'
  reviewedBy  String? // Admin-ID
  reviewedAt  DateTime?
  resolution  String? // Was wurde gemacht
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  watch       Watch     @relation(fields: [watchId], references: [id], onDelete: Cascade)
  reporter    User      @relation("ReportedBy", fields: [reportedBy], references: [id])
  reviewer    User?     @relation("ReviewedBy", fields: [reviewedBy], references: [id])

  @@index([watchId])
  @@index([status])
  @@index([createdAt])
  @@map("reports")
}

// User-Meldungen (ähnlich wie Report für Artikel)
model UserReport {
  id             String    @id @default(cuid())
  reportedUserId String // User-ID des gemeldeten Users
  reportedBy     String // User-ID des Meldenden
  reason         String // 'spam', 'fraud', 'harassment', 'inappropriate', 'scam', 'fake_account', 'other'
  description    String? // Zusätzliche Beschreibung
  status         String    @default("pending") // 'pending', 'reviewing', 'resolved', 'dismissed'
  reviewedBy     String? // Admin-ID
  reviewedAt     DateTime?
  resolution     String? // Was wurde gemacht (z.B. 'warned', 'blocked', 'dismissed')
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  reportedUser   User      @relation("ReportedUser", fields: [reportedUserId], references: [id], onDelete: Cascade)
  reporter       User      @relation("UserReportedBy", fields: [reportedBy], references: [id])
  reviewer       User?     @relation("UserReportReviewedBy", fields: [reviewedBy], references: [id])

  @@index([reportedUserId])
  @@index([status])
  @@index([createdAt])
  @@map("user_reports")
}

// Admin-Notizen zu Angeboten
model AdminNote {
  id        String   @id @default(cuid())
  watchId   String
  adminId   String // Admin-ID
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)
  admin     User     @relation(fields: [adminId], references: [id])

  @@index([watchId])
  @@index([createdAt])
  @@map("admin_notes")
}

// Moderation-Historie
model ModerationHistory {
  id        String   @id @default(cuid())
  watchId   String
  adminId   String // Admin-ID
  action    String // 'activated', 'deactivated', 'deleted', 'edited', 'reported', 'note_added'
  details   String? // JSON mit Details
  createdAt DateTime @default(now())
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)
  admin     User     @relation(fields: [adminId], references: [id])

  @@index([watchId])
  @@index([createdAt])
  @@map("moderation_history")
}

// Aufrufe-Tracking für Statistiken
model WatchView {
  id        String   @id @default(cuid())
  watchId   String
  userId    String? // Optional, falls angemeldet
  ipAddress String?
  userAgent String?
  viewedAt  DateTime @default(now())
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([viewedAt])
  @@map("watch_views")
}

// Admin-Notizen zu Benutzern
model UserAdminNote {
  id        String   @id @default(cuid())
  userId    String
  adminId   String // Admin-ID
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation("UserAdminNoteUser", fields: [userId], references: [id], onDelete: Cascade)
  admin     User     @relation("UserAdminNoteAdmin", fields: [adminId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@map("user_admin_notes")
}

// User-Aktivitäts-Historie
model UserActivity {
  id        String   @id @default(cuid())
  userId    String
  action    String // 'watch_created', 'watch_sold', 'purchase_completed', 'user_reported', 'reported_user', 'contact_form_sent', 'verification_submitted', 'verification_approved', 'verification_rejected', 'blocked', 'unblocked', 'warned', 'admin_note_added', etc.
  details   String? // JSON mit Details (z.B. watchId, purchaseId, etc.)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@map("user_activities")
}

// ============================================
// HOMEPAGE ENHANCEMENT FEATURES - PHASE 0
// ============================================

// Feature 1: Intelligente Suche - Search Analytics
model SearchQuery {
  id             String   @id @default(cuid())
  query          String
  userId         String?
  category       String?
  resultCount    Int      @default(0)
  clicked        Boolean  @default(false)
  clickedWatchId String?
  createdAt      DateTime @default(now())
  user           User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([query])
  @@index([createdAt])
  @@index([userId])
  @@index([category])
  @@map("search_queries")
}

// Feature 2: Social Proof - Product Statistics
model ProductStats {
  id            String   @id @default(cuid())
  watchId       String   @unique
  favoriteCount Int      @default(0)
  viewCount     Int      @default(0)
  soldLast24h   Int      @default(0)
  viewersNow    Int      @default(0) // Aktuelle Viewer (wird regelmäßig aktualisiert)
  lastUpdated   DateTime @default(now())
  watch         Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([lastUpdated])
  @@map("product_stats")
}

// Feature 3: Lokale Karte - Koordinaten-Cache für Performance
model PostalCodeCache {
  id         String   @id @default(cuid())
  postalCode String   @unique
  latitude   Float
  longitude  Float
  city       String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([postalCode])
  @@map("postal_code_cache")
}

// Feature 3: Lokale Karte - Nutzt bestehende postalCode/city Felder
// Kein neues Model nötig, nutzt Watch.postalCode und Watch.city

// Feature 4: Smart Collections
model Collection {
  id          String           @id @default(cuid())
  name        String
  description String?
  type        String           @default("user") // 'system' oder 'user'
  userId      String?
  imageUrl    String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User?            @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       CollectionItem[]

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("collections")
}

model CollectionItem {
  id           String     @id @default(cuid())
  collectionId String
  watchId      String
  order        Int        @default(0)
  addedAt      DateTime   @default(now())
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  watch        Watch      @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@unique([collectionId, watchId])
  @@index([collectionId])
  @@index([watchId])
  @@index([order])
  @@map("collection_items")
}

// Feature 5: Personalisierung
model BrowsingHistory {
  id       String   @id @default(cuid())
  userId   String
  watchId  String
  viewedAt DateTime @default(now())
  duration Int?     @default(0) // Sekunden
  action   String   @default("view") // 'view', 'favorite', 'click', 'purchase'
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  watch    Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, viewedAt])
  @@index([watchId])
  @@index([action])
  @@map("browsing_history")
}

model UserPreferences {
  id                  String   @id @default(cuid())
  userId              String   @unique
  preferredCategories String? // JSON Array
  priceRange          String? // JSON: {min: number, max: number}
  preferredBrands     String? // JSON Array
  preferredConditions String? // JSON Array
  updatedAt           DateTime @default(now())
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_preferences")
}

// Feature 6: Live-Auktionen
model AuctionViewer {
  id       String   @id @default(cuid())
  watchId  String
  userId   String?
  joinedAt DateTime @default(now())
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  watch    Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([joinedAt])
  @@index([userId])
  @@map("auction_viewers")
}

// Feature 7: Video-Highlights - Nutzt bestehendes Watch.video Feld
// Kein neues Model nötig

// Feature 8: Story-Feature
model Story {
  id        String   @id @default(cuid())
  sellerId  String
  watchId   String?
  imageUrl  String?
  videoUrl  String?
  text      String?
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  watch     Watch?   @relation(fields: [watchId], references: [id], onDelete: SetNull)

  @@index([sellerId])
  @@index([expiresAt])
  @@index([createdAt])
  @@index([watchId])
  @@map("stories")
}

// Feature 9: Gamification
model UserBadge {
  id           String   @id @default(cuid())
  userId       String
  badgeType    String // 'FIRST_PURCHASE', 'POWER_BUYER_10', 'POWER_BUYER_50', 'POWER_SELLER', 'LOYAL_CUSTOMER', 'STREAK_7', 'STREAK_30'
  displayOrder Int      @default(0)
  earnedAt     DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeType])
  @@index([userId])
  @@index([badgeType])
  @@map("user_badges")
}

model UserStreak {
  id            String   @id @default(cuid())
  userId        String   @unique
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastVisitDate DateTime @default(now())
  totalVisits   Int      @default(0)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_streaks")
}

model DailyDeal {
  id              String   @id @default(cuid())
  watchId         String
  discountPercent Float
  startDate       DateTime
  endDate         DateTime
  maxQuantity     Int      @default(1)
  soldQuantity    Int      @default(0)
  createdAt       DateTime @default(now())

  @@index([startDate])
  @@index([endDate])
  @@index([watchId])
  @@map("daily_deals")
}

model Reward {
  id          String    @id @default(cuid())
  userId      String
  rewardType  String // 'discount', 'free_booster', 'premium_feature'
  rewardValue String // JSON: {percent: number} oder {boosterCode: string}
  claimedAt   DateTime?
  expiresAt   DateTime
  usedAt      DateTime?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([claimedAt])
  @@map("rewards")
}

// Feature 10: AI-Powered Chat
// Nutzt bestehende Conversation und ConversationMessage Models
// Erweitert mit zusätzlichen Feldern für Produkt-Empfehlungen

model AIConversation {
  id        String           @id @default(cuid())
  userId    String
  messages  String           @default("[]") // JSON Array
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  results   AISearchResult[]

  @@index([userId])
  @@index([createdAt])
  @@map("ai_conversations")
}

model AISearchResult {
  id              String          @id @default(cuid())
  conversationId  String?
  watchId         String
  query           String
  productIds      String          @default("[]") // JSON Array
  clickedProducts String?         @default("[]") // JSON Array
  createdAt       DateTime        @default(now())
  conversation    AIConversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  watch           Watch           @relation(fields: [watchId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String

  @@index([conversationId])
  @@index([watchId])
  @@index([userId])
  @@index([createdAt])
  @@map("ai_search_results")
}

model PricingHistory {
  id                String   @id @default(cuid())
  platformMarginRate Float?
  vatRate           Float?
  minimumCommission Float?
  maximumCommission Float?
  listingFee        Float?
  transactionFee    Float?
  changedBy         String
  changedAt         DateTime @default(now())
  admin             User     @relation(fields: [changedBy], references: [id], onDelete: Cascade)
  
  @@index([changedAt])
  @@index([changedBy])
  @@map("pricing_history")
}
