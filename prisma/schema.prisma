generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                            String               @id @default(cuid())
  email                         String               @unique
  name                          String?
  title                         String?
  firstName                     String?
  lastName                      String?
  password                      String?
  image                         String?
  createdAt                     DateTime             @default(now())
  updatedAt                     DateTime             @updatedAt
  emailVerified                 Boolean              @default(false)
  emailVerifiedAt               DateTime?
  emailVerificationToken        String?
  emailVerificationTokenExpires DateTime?
  nickname                      String?
  bio                           String?
  specialization                String?
  profileComplete               Boolean              @default(false)
  dateOfBirth                   DateTime?
  nationality                   String?
  phone                         String?
  phoneVerified                 Boolean              @default(false)
  street                        String?
  streetNumber                  String?
  postalCode                    String?
  city                          String?
  country                       String?
  addresszusatz                 String? // Optional: c/o, apartment, etc.
  kanton                        String? // Optional: Swiss canton
  billingStreet                 String?
  billingStreetNumber           String?
  billingPostalCode             String?
  billingCity                   String?
  billingCountry                String?
  deliveryStreet                String?
  deliveryStreetNumber          String?
  deliveryPostalCode            String?
  deliveryCity                  String?
  deliveryCountry               String?
  paymentMethods                String?
  idDocument                    String?
  idDocumentPage1               String?
  idDocumentPage2               String?
  idDocumentType                String?
  companyName                   String?
  accountType                   String?
  verified                      Boolean              @default(false)
  verificationLevel             String?
  verifiedAt                    DateTime?
  verificationStatus            String?              @default("pending")
  verificationReviewedAt        DateTime?
  verificationReviewedBy        String?
  isAdmin                       Boolean              @default(false)
  isBlocked                     Boolean              @default(false)
  blockedAt                     DateTime?
  blockedBy                     String?
  blockedReason                 String?
  warningCount                  Int                  @default(0)
  lastWarnedAt                  DateTime?
  hasUnpaidInvoices             Boolean              @default(false)
  lastInvoiceReminderAt         DateTime?
  stripeConnectedAccountId      String?
  stripeOnboardingComplete      Boolean              @default(false)
  stripeOnboardingLinkExpiresAt DateTime?
  connectOnboardingStatus       String               @default("NOT_STARTED") // NOT_STARTED, IN_PROGRESS, ACTION_REQUIRED, VERIFIED
  payoutsEnabled                Boolean              @default(false)
  chargesEnabled                Boolean              @default(false)
  stripeRequirements            Json?                // Snapshot of Stripe requirements for UI
  accounts                      Account[]
  bids                          Bid[]
  favorites                     Favorite[]
  invoices                      Invoice[]
  receivedMessages              Message[]            @relation("MessageReceiver")
  messages                      Message[]            @relation("MessageSender")
  notifications                 Notification[]
  priceOffers                   PriceOffer[]
  purchases                     Purchase[]
  receivedReviews               Review[]             @relation("ReviewedUser")
  reviews                       Review[]
  salePurchases                 Sale[]               @relation("SaleBuyer")
  sales                         Sale[]
  searchSubscriptions           SearchSubscription[]
  sessions                      Session[]
  watches                       Watch[]
  conversations                 Conversation[]
  reportsMade                   Report[]             @relation("ReportedBy")
  reportsReviewed               Report[]             @relation("ReviewedBy")
  userReportsMade               UserReport[]         @relation("UserReportedBy")
  userReportsReviewed           UserReport[]         @relation("UserReportReviewedBy")
  userReportsReceived           UserReport[]         @relation("ReportedUser")
  adminNotes                    AdminNote[]
  moderationHistory             ModerationHistory[]
  maxBids                       MaxBid[]
  userAdminNotes                UserAdminNote[]      @relation("UserAdminNoteAdmin")
  userAdminNotesForUser         UserAdminNote[]      @relation("UserAdminNoteUser")
  userActivities                UserActivity[]
  searchQueries                 SearchQuery[]
  userPreferences               UserPreferences?
  collections                   Collection[]
  auctionViewers                AuctionViewer[]
  stories                       Story[]
  browsingHistory               BrowsingHistory[]
  userBadges                    UserBadge[]
  userStreaks                   UserStreak?
  rewards                       Reward[]
  aiConversations               AIConversation[]
  aiSearchResults               AISearchResult[]
  ordersAsBuyer                 Order[]              @relation("OrderBuyer")
  ordersAsSeller                Order[]              @relation("OrderSeller")
  pricingHistory                PricingHistory[]
  drafts                        Draft[]
  payoutProfile                 PayoutProfile?
  payoutChangeRequestsDecided   PayoutChangeRequest[] @relation("PayoutChangeDecider")
  payoutAuditLogs               PayoutAuditLog[]     @relation("PayoutAuditActor")
  disputeComments               DisputeComment[]

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Watch {
  id                       String              @id @default(cuid())
  articleNumber            Int?                @unique
  title                    String
  description              String?
  brand                    String
  model                    String
  // searchText is temporarily commented out - column doesn't exist in production DB yet
  // Run migration 20250629_add_search_text_fts to enable full-text search
  // searchText               String              @default("") // Full-text search field combining all searchable content
  year                     Int?
  condition                String
  material                 String?
  movement                 String?
  caseSize                 Float?
  caseDiameter             Float?
  price                    Float
  buyNowPrice              Float?
  isAuction                Boolean             @default(false)
  auctionStart             DateTime?
  auctionEnd               DateTime?
  auctionDuration          Int?
  autoRenew                Boolean             @default(false)
  lastBidAt                DateTime?
  images                   String
  video                    String?
  createdAt                DateTime            @default(now())
  updatedAt                DateTime            @updatedAt
  lastRevision             DateTime?
  accuracy                 String?
  fullset                  Boolean             @default(false)
  allLinks                 Boolean             @default(false)
  box                      Boolean             @default(false)
  papers                   Boolean             @default(false)
  warranty                 String?
  warrantyMonths           Int?
  warrantyYears            Int?
  warrantyNote             String?
  warrantyDescription      String?
  referenceNumber          String?
  shippingMethod           String?
  boosters                 String?
  paymentProtectionEnabled Boolean             @default(false)

  // Note: deliveryMode, freeShippingThresholdChf, pickupLocationZip, pickupLocationCity,
  // pickupLocationAddress, shippingProfile columns are NOT in the database yet.
  // These features are handled via shippingMethod JSON or will be added in a future migration.

  sellerId                 String
  moderationStatus         String?             @default("pending") // 'pending', 'approved', 'rejected', 'reviewing'
  moderatedBy              String?
  moderatedAt              DateTime?
  moderationNotes          String?
  bids                     Bid[]
  favorites                Favorite[]
  invoiceItems             InvoiceItem[]
  messages                 Message[]
  priceOffers              PriceOffer[]
  purchases                Purchase[]
  sales                    Sale[]
  orders                   Order[]
  categories               WatchCategory[]
  seller                   User                @relation(fields: [sellerId], references: [id])
  reports                  Report[]
  adminNotes               AdminNote[]
  moderationHistory        ModerationHistory[]
  views                    WatchView[]
  maxBids                  MaxBid[]
  productStats             ProductStats?
  collectionItems          CollectionItem[]
  auctionViewers           AuctionViewer[]
  stories                  Story[]
  browsingHistory          BrowsingHistory[]
  aiSearchResults          AISearchResult[]

  @@index([moderationStatus])
  @@index([createdAt])
  @@index([sellerId]) // KRITISCH: Für schnelle Abfragen nach sellerId
  @@index([sellerId, createdAt]) // OPTIMIERT: Für Sortierung nach createdAt bei sellerId-Filter
  @@index([title]) // PERFORMANCE: Für schnelle Textsuche
  @@index([brand]) // PERFORMANCE: Für schnelle Brand-Filterung
  @@index([price]) // PERFORMANCE: Für schnelle Preis-Sortierung
  @@index([articleNumber]) // PERFORMANCE: Für schnelle Artikelnummer-Lookups
  @@index([auctionEnd]) // PERFORMANCE: Für schnelle Auktion-Filterung
  @@index([title, brand]) // PERFORMANCE: Composite Index für kombinierte Suche
  // @@index([searchText]) // DISABLED: searchText column not in production DB yet
  @@map("watches")
}

model Bid {
  id        String   @id @default(cuid())
  amount    Float
  createdAt DateTime @default(now())
  watchId   String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@index([watchId]) // OPTIMIERT: Für schnelle Bid-Abfragen
  @@index([watchId, amount]) // OPTIMIERT: Für Sortierung nach amount bei watchId-Filter
  @@map("bids")
}

// Automatisches Gebot (Maximalgebot)
model MaxBid {
  id         String   @id @default(cuid())
  watchId    String
  userId     String
  maxAmount  Float // Maximales Gebot
  currentBid Float? // Aktuelles Gebot (wird automatisch erhöht)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  user       User     @relation(fields: [userId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, userId]) // Ein MaxBid pro User pro Watch
  @@index([watchId])
  @@index([userId])
  @@map("max_bids")
}

model Purchase {
  id                             String            @id @default(cuid())
  price                          Float?
  shippingMethod                 String?
  status                         String            @default("pending")
  itemReceived                   Boolean           @default(false)
  itemReceivedAt                 DateTime?
  paymentConfirmed               Boolean           @default(false)
  paymentConfirmedAt             DateTime?
  contactDeadline                DateTime
  sellerContactedAt              DateTime?
  buyerContactedAt               DateTime?
  contactWarningSentAt           DateTime?
  contactDeadlineMissed          Boolean           @default(false)
  paymentDeadline                DateTime?
  paymentReminderSentAt          DateTime?
  paymentReminderCount           Int               @default(0)
  paymentDeadlineMissed          Boolean           @default(false)
  trackingNumber                 String?
  trackingProvider               String?
  shippedAt                      DateTime?
  estimatedDeliveryDate          DateTime?
  // === DISPUTE SYSTEM (Enhanced) ===
  disputeOpenedAt                DateTime?
  disputeReason                  String?
  disputeDescription             String?
  disputeStatus                  String?           // pending, under_review, resolved, rejected, closed
  disputeResolvedAt              DateTime?
  disputeResolvedBy              String?
  disputeInitiatedBy             String?           // 'buyer' or 'seller' - who opened the dispute
  disputeDeadline                DateTime?         // Deadline for resolution (14 days after opening)
  disputeFrozenAt                DateTime?         // When purchase was frozen due to dispute
  disputeAttachments             String?           // JSON array of file URLs for evidence
  disputeReminderSentAt          DateTime?         // Last reminder sent
  disputeReminderCount           Int               @default(0)
  // === STRIPE INTEGRATION ===
  stripePaymentIntentId          String?           // Stripe PaymentIntent ID for refunds
  stripeRefundId                 String?           // Stripe Refund ID if refunded
  stripeRefundStatus             String?           // pending, succeeded, failed
  stripeRefundedAt               DateTime?
  // === CANCELLATION REQUEST ===
  cancellationRequestedAt        DateTime?
  cancellationRequestStatus      String?
  cancellationRequestReason      String?
  cancellationRequestDescription String?
  cancellationRequestResolvedAt  DateTime?
  cancellationRequestResolvedBy  String?
  statusHistory                  String?
  paid                           Boolean           @default(false)
  paidAt                         DateTime?
  createdAt                      DateTime          @default(now())
  updatedAt                      DateTime          @updatedAt
  watchId                        String
  buyerId                        String
  priceOffers                    PriceOffer[]
  buyer                          User              @relation(fields: [buyerId], references: [id])
  watch                          Watch             @relation(fields: [watchId], references: [id])
  reviews                        Review[]
  disputeComments                DisputeComment[]

  @@index([watchId]) // OPTIMIERT: Für schnelle Purchase-Abfragen
  @@index([watchId, status]) // OPTIMIERT: Für Filterung nach Status bei watchId-Filter
  @@index([disputeStatus]) // OPTIMIERT: Für Dispute-Übersicht
  @@map("purchases")
}

// === DISPUTE COMMENT SYSTEM ===
// Tracks all comments and actions in a dispute for full history
model DisputeComment {
  id          String   @id @default(cuid())
  purchaseId  String
  userId      String
  userRole    String   // 'buyer', 'seller', 'admin'
  type        String   // 'comment', 'status_change', 'evidence_uploaded', 'reminder_sent', 'resolution'
  content     String   // Comment text or action description
  attachments String?  // JSON array of file URLs
  isInternal  Boolean  @default(false) // Admin-only notes
  createdAt   DateTime @default(now())

  purchase Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@index([purchaseId])
  @@index([purchaseId, createdAt])
  @@map("dispute_comments")
}

model Sale {
  id        String   @id @default(cuid())
  price     Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  watchId   String
  sellerId  String
  buyerId   String?
  reviews   Review[]
  buyer     User?    @relation("SaleBuyer", fields: [buyerId], references: [id])
  seller    User     @relation(fields: [sellerId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@map("sales")
}

model Payment {
  id        String   @id @default(cuid())
  amount    Float
  status    String
  createdAt DateTime @default(now())

  @@map("payments")
}

model Review {
  id             String    @id @default(cuid())
  rating         String
  comment        String?
  createdAt      DateTime  @default(now())
  reviewerId     String
  reviewedUserId String
  purchaseId     String?
  saleId         String?
  sale           Sale?     @relation(fields: [saleId], references: [id])
  purchase       Purchase? @relation(fields: [purchaseId], references: [id])
  reviewedUser   User      @relation("ReviewedUser", fields: [reviewedUserId], references: [id])
  reviewer       User      @relation(fields: [reviewerId], references: [id])

  @@unique([purchaseId, reviewerId])
  @@unique([saleId, reviewerId])
  @@map("reviews")
}

model Favorite {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  watchId   String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  watch     Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, userId])
  @@map("favorites")
}

model Category {
  id        String          @id @default(cuid())
  name      String          @unique
  slug      String          @unique
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  watches   WatchCategory[]

  @@map("categories")
}

model WatchCategory {
  id         String   @id @default(cuid())
  watchId    String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@unique([watchId, categoryId])
  @@map("watch_categories")
}

model Message {
  id         String   @id @default(cuid())
  content    String
  createdAt  DateTime @default(now())
  read       Boolean  @default(false)
  isPublic   Boolean  @default(false)
  watchId    String
  senderId   String
  receiverId String
  receiver   User     @relation("MessageReceiver", fields: [receiverId], references: [id])
  sender     User     @relation("MessageSender", fields: [senderId], references: [id])
  watch      Watch    @relation(fields: [watchId], references: [id])

  @@map("messages")
}

model Invoice {
  id                   String        @id @default(cuid())
  invoiceNumber        String        @unique
  sellerId             String
  saleId               String?
  subtotal             Float
  vatRate              Float         @default(0.081)
  vatAmount            Float
  total                Float
  status               String        @default("pending")
  paidAt               DateTime?
  dueDate              DateTime
  paymentMethod        String?
  paymentReference     String?
  paymentConfirmedAt   DateTime?
  qrCode               String?
  paymentRequestSentAt DateTime?
  firstReminderSentAt  DateTime?
  secondReminderSentAt DateTime?
  finalReminderSentAt  DateTime?
  reminderCount        Int           @default(0)
  lateFeeAdded         Boolean       @default(false)
  lateFeeAmount        Float         @default(0)
  accountBlockedAt     DateTime?
  accountBlockedReason String?
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  refundedAt           DateTime?
  originalInvoiceId    String? // Verknüpfung zur ursprünglichen Rechnung bei Korrektur-Rechnungen
  originalInvoice      Invoice?      @relation("InvoiceCorrection", fields: [originalInvoiceId], references: [id])
  correctionInvoices   Invoice[]     @relation("InvoiceCorrection")
  items                InvoiceItem[]
  seller               User          @relation(fields: [sellerId], references: [id])

  @@map("invoices")
}

model InvoiceItem {
  id          String   @id @default(cuid())
  invoiceId   String
  watchId     String?
  description String
  quantity    Int      @default(1)
  price       Float
  total       Float
  createdAt   DateTime @default(now())
  watch       Watch?   @relation(fields: [watchId], references: [id])
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])

  @@map("invoice_items")
}

model BoosterPrice {
  id          String   @id @default(cuid())
  code        String   @unique
  name        String
  description String?
  price       Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("booster_prices")
}

model PriceOffer {
  id         String    @id @default(cuid())
  amount     Float
  message    String?
  status     String    @default("pending")
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  watchId    String
  buyerId    String
  purchaseId String?
  purchase   Purchase? @relation(fields: [purchaseId], references: [id])
  buyer      User      @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  watch      Watch     @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@map("price_offers")
}

model Notification {
  id           String    @id @default(cuid())
  type         String
  title        String
  message      String
  link         String?
  isRead       Boolean   @default(false)
  readAt       DateTime?
  createdAt    DateTime  @default(now())
  userId       String
  watchId      String?
  bidId        String?
  questionId   String?
  priceOfferId String?
  purchaseId   String?
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

model SearchSubscription {
  id            String    @id @default(cuid())
  userId        String
  searchTerm    String?
  brand         String?
  model         String?
  categoryId    String?
  subcategoryId String?
  minPrice      Float?
  maxPrice      Float?
  condition     String?
  yearFrom      Int?
  yearTo        Int?
  isActive      Boolean   @default(true)
  matchesFound  Int       @default(0)
  lastMatchAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([isActive])
  @@map("search_subscriptions")
}

model Conversation {
  id        String                @id @default(cuid())
  userId    String?
  context   String? // JSON string mit Kontext (productId, etc.)
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  messages  ConversationMessage[]
  user      User?                 @relation(fields: [userId], references: [id])

  @@map("conversations")
}

model ConversationMessage {
  id             String       @id @default(cuid())
  conversationId String
  role           String // 'user' | 'assistant' | 'system'
  content        String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("conversation_messages")
}

model ContactRequest {
  id         String    @id @default(cuid())
  category   String // 'technical', 'account', 'payment', 'safety', 'general', 'feedback', 'other'
  email      String
  subject    String
  message    String
  status     String    @default("pending") // 'pending', 'in_progress', 'resolved', 'closed'
  resolvedAt DateTime?
  resolvedBy String?
  notes      String? // Admin-Notizen
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([status])
  @@index([createdAt])
  @@map("contact_requests")
}

// Melde-System für Angebote
model Report {
  id          String    @id @default(cuid())
  watchId     String
  reportedBy  String // User-ID des Meldenden
  reason      String // 'spam', 'fraud', 'wrong_category', 'inappropriate', 'duplicate', 'other'
  description String? // Zusätzliche Beschreibung
  status      String    @default("pending") // 'pending', 'reviewing', 'resolved', 'dismissed'
  reviewedBy  String? // Admin-ID
  reviewedAt  DateTime?
  resolution  String? // Was wurde gemacht
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  watch       Watch     @relation(fields: [watchId], references: [id], onDelete: Cascade)
  reporter    User      @relation("ReportedBy", fields: [reportedBy], references: [id])
  reviewer    User?     @relation("ReviewedBy", fields: [reviewedBy], references: [id])

  @@index([watchId])
  @@index([status])
  @@index([createdAt])
  @@map("reports")
}

// User-Meldungen (ähnlich wie Report für Artikel)
model UserReport {
  id             String    @id @default(cuid())
  reportedUserId String // User-ID des gemeldeten Users
  reportedBy     String // User-ID des Meldenden
  reason         String // 'spam', 'fraud', 'harassment', 'inappropriate', 'scam', 'fake_account', 'other'
  description    String? // Zusätzliche Beschreibung
  status         String    @default("pending") // 'pending', 'reviewing', 'resolved', 'dismissed'
  reviewedBy     String? // Admin-ID
  reviewedAt     DateTime?
  resolution     String? // Was wurde gemacht (z.B. 'warned', 'blocked', 'dismissed')
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  reportedUser   User      @relation("ReportedUser", fields: [reportedUserId], references: [id], onDelete: Cascade)
  reporter       User      @relation("UserReportedBy", fields: [reportedBy], references: [id])
  reviewer       User?     @relation("UserReportReviewedBy", fields: [reviewedBy], references: [id])

  @@index([reportedUserId])
  @@index([status])
  @@index([createdAt])
  @@map("user_reports")
}

// Admin-Notizen zu Angeboten
model AdminNote {
  id        String   @id @default(cuid())
  watchId   String
  adminId   String // Admin-ID
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)
  admin     User     @relation(fields: [adminId], references: [id])

  @@index([watchId])
  @@index([createdAt])
  @@map("admin_notes")
}

// Moderation-Historie
model ModerationHistory {
  id        String   @id @default(cuid())
  watchId   String
  adminId   String // Admin-ID
  action    String // 'activated', 'deactivated', 'deleted', 'edited', 'reported', 'note_added'
  details   String? // JSON mit Details
  createdAt DateTime @default(now())
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)
  admin     User     @relation(fields: [adminId], references: [id])

  @@index([watchId])
  @@index([createdAt])
  @@map("moderation_history")
}

// Aufrufe-Tracking für Statistiken
model WatchView {
  id        String   @id @default(cuid())
  watchId   String
  userId    String? // Optional, falls angemeldet
  ipAddress String?
  userAgent String?
  viewedAt  DateTime @default(now())
  watch     Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([viewedAt])
  @@map("watch_views")
}

// Admin-Notizen zu Benutzern
model UserAdminNote {
  id        String   @id @default(cuid())
  userId    String
  adminId   String // Admin-ID
  note      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation("UserAdminNoteUser", fields: [userId], references: [id], onDelete: Cascade)
  admin     User     @relation("UserAdminNoteAdmin", fields: [adminId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@map("user_admin_notes")
}

// User-Aktivitäts-Historie
model UserActivity {
  id        String   @id @default(cuid())
  userId    String
  action    String // 'watch_created', 'watch_sold', 'purchase_completed', 'user_reported', 'reported_user', 'contact_form_sent', 'verification_submitted', 'verification_approved', 'verification_rejected', 'blocked', 'unblocked', 'warned', 'admin_note_added', etc.
  details   String? // JSON mit Details (z.B. watchId, purchaseId, etc.)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@map("user_activities")
}

// ============================================
// HOMEPAGE ENHANCEMENT FEATURES - PHASE 0
// ============================================

// Feature 1: Intelligente Suche - Search Analytics
model SearchQuery {
  id             String   @id @default(cuid())
  query          String
  userId         String?
  category       String?
  resultCount    Int      @default(0)
  clicked        Boolean  @default(false)
  clickedWatchId String?
  createdAt      DateTime @default(now())
  user           User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([query])
  @@index([createdAt])
  @@index([userId])
  @@index([category])
  @@map("search_queries")
}

// Feature 2: Social Proof - Product Statistics
model ProductStats {
  id            String   @id @default(cuid())
  watchId       String   @unique
  favoriteCount Int      @default(0)
  viewCount     Int      @default(0)
  soldLast24h   Int      @default(0)
  viewersNow    Int      @default(0) // Aktuelle Viewer (wird regelmäßig aktualisiert)
  lastUpdated   DateTime @default(now())
  watch         Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([lastUpdated])
  @@map("product_stats")
}

// Feature 3: Lokale Karte - Koordinaten-Cache für Performance
model PostalCodeCache {
  id         String   @id @default(cuid())
  postalCode String   @unique
  latitude   Float
  longitude  Float
  city       String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([postalCode])
  @@map("postal_code_cache")
}

// Feature 3: Lokale Karte - Nutzt bestehende postalCode/city Felder
// Kein neues Model nötig, nutzt Watch.postalCode und Watch.city

// Feature 4: Smart Collections
model Collection {
  id          String           @id @default(cuid())
  name        String
  description String?
  type        String           @default("user") // 'system' oder 'user'
  userId      String?
  imageUrl    String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  user        User?            @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       CollectionItem[]

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("collections")
}

model CollectionItem {
  id           String     @id @default(cuid())
  collectionId String
  watchId      String
  order        Int        @default(0)
  addedAt      DateTime   @default(now())
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  watch        Watch      @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@unique([collectionId, watchId])
  @@index([collectionId])
  @@index([watchId])
  @@index([order])
  @@map("collection_items")
}

// Feature 5: Personalisierung
model BrowsingHistory {
  id       String   @id @default(cuid())
  userId   String
  watchId  String
  viewedAt DateTime @default(now())
  duration Int?     @default(0) // Sekunden
  action   String   @default("view") // 'view', 'favorite', 'click', 'purchase'
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  watch    Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, viewedAt])
  @@index([watchId])
  @@index([action])
  @@map("browsing_history")
}

model UserPreferences {
  id                  String   @id @default(cuid())
  userId              String   @unique
  preferredCategories String? // JSON Array
  priceRange          String? // JSON: {min: number, max: number}
  preferredBrands     String? // JSON Array
  preferredConditions String? // JSON Array
  updatedAt           DateTime @default(now())
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_preferences")
}

// Feature 6: Live-Auktionen
model AuctionViewer {
  id       String   @id @default(cuid())
  watchId  String
  userId   String?
  joinedAt DateTime @default(now())
  user     User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  watch    Watch    @relation(fields: [watchId], references: [id], onDelete: Cascade)

  @@index([watchId])
  @@index([joinedAt])
  @@index([userId])
  @@map("auction_viewers")
}

// Feature 7: Video-Highlights - Nutzt bestehendes Watch.video Feld
// Kein neues Model nötig

// Feature 8: Story-Feature
model Story {
  id        String   @id @default(cuid())
  sellerId  String
  watchId   String?
  imageUrl  String?
  videoUrl  String?
  text      String?
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  watch     Watch?   @relation(fields: [watchId], references: [id], onDelete: SetNull)

  @@index([sellerId])
  @@index([expiresAt])
  @@index([createdAt])
  @@index([watchId])
  @@map("stories")
}

// Feature 9: Gamification
model UserBadge {
  id           String   @id @default(cuid())
  userId       String
  badgeType    String // 'FIRST_PURCHASE', 'POWER_BUYER_10', 'POWER_BUYER_50', 'POWER_SELLER', 'LOYAL_CUSTOMER', 'STREAK_7', 'STREAK_30'
  displayOrder Int      @default(0)
  earnedAt     DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeType])
  @@index([userId])
  @@index([badgeType])
  @@map("user_badges")
}

model UserStreak {
  id            String   @id @default(cuid())
  userId        String   @unique
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastVisitDate DateTime @default(now())
  totalVisits   Int      @default(0)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_streaks")
}

model DailyDeal {
  id              String   @id @default(cuid())
  watchId         String
  discountPercent Float
  startDate       DateTime
  endDate         DateTime
  maxQuantity     Int      @default(1)
  soldQuantity    Int      @default(0)
  createdAt       DateTime @default(now())

  @@index([startDate])
  @@index([endDate])
  @@index([watchId])
  @@map("daily_deals")
}

model Reward {
  id          String    @id @default(cuid())
  userId      String
  rewardType  String // 'discount', 'free_booster', 'premium_feature'
  rewardValue String // JSON: {percent: number} oder {boosterCode: string}
  claimedAt   DateTime?
  expiresAt   DateTime
  usedAt      DateTime?
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([claimedAt])
  @@map("rewards")
}

// Feature 10: AI-Powered Chat
// Nutzt bestehende Conversation und ConversationMessage Models
// Erweitert mit zusätzlichen Feldern für Produkt-Empfehlungen

model AIConversation {
  id        String           @id @default(cuid())
  userId    String
  messages  String           @default("[]") // JSON Array
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  results   AISearchResult[]

  @@index([userId])
  @@index([createdAt])
  @@map("ai_conversations")
}

model AISearchResult {
  id              String          @id @default(cuid())
  conversationId  String?
  watchId         String
  query           String
  productIds      String          @default("[]") // JSON Array
  clickedProducts String?         @default("[]") // JSON Array
  createdAt       DateTime        @default(now())
  conversation    AIConversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  watch           Watch           @relation(fields: [watchId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String

  @@index([conversationId])
  @@index([watchId])
  @@index([userId])
  @@index([createdAt])
  @@map("ai_search_results")
}

model Order {
  id          String @id @default(cuid())
  orderNumber String @unique
  watchId     String
  buyerId     String
  sellerId    String

  // Pricing
  itemPrice     Float
  shippingCost  Float // Deprecated - use shippingCostChfFinal
  platformFee   Float
  protectionFee Float?
  totalAmount   Float

  // Shipping Details (Ricardo-style)
  selectedDeliveryMode      String?            // 'shipping' | 'pickup'
  selectedShippingCode      String?            // z.B. 'post_economy_2kg'
  selectedAddons            String?            // JSON Array: ['sperrgut', 'pickhome']
  shippingCostChfFinal      Float              @default(0) // Finaler Versandpreis (inkl. Add-ons, free shipping)
  shippingCostBreakdown      String?            // JSON: {base: number, sperrgut: number, pickhome: number, free_shipping_applied: bool}
  shippingRateSetId         String?           @default("default_ch_post") // Rate-Set Identifier

  // Stripe IDs
  stripePaymentIntentId   String?
  stripeChargeId          String?
  stripeCheckoutSessionId String?
  stripeTransferId        String?
  stripeRefundId          String?

  // Status
  orderStatus   String @default("awaiting_payment")
  paymentStatus String @default("created")

  // Timeline
  paidAt        DateTime?
  shippedAt     DateTime?
  deliveredAt   DateTime?
  releasedAt    DateTime?
  refundedAt    DateTime?
  autoReleaseAt DateTime?

  // Buyer confirmation
  buyerConfirmedReceipt Boolean   @default(false)
  buyerConfirmedAt      DateTime?

  // Dispute
  disputeStatus      String    @default("none")
  disputeOpenedAt    DateTime?
  disputeReason      String?
  disputeDescription String?
  disputeResolvedAt  DateTime?
  disputeResolvedBy  String?

  // Tracking
  trackingNumber   String?
  trackingProvider String?

  // Relations
  watch         Watch          @relation(fields: [watchId], references: [id])
  buyer         User           @relation("OrderBuyer", fields: [buyerId], references: [id])
  seller        User           @relation("OrderSeller", fields: [sellerId], references: [id])
  paymentRecord PaymentRecord?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([buyerId])
  @@index([sellerId])
  @@index([watchId])
  @@index([orderStatus])
  @@index([paymentStatus])
  @@index([stripePaymentIntentId])
  @@index([autoReleaseAt])
  @@map("orders")
}

model PaymentRecord {
  id      String @id @default(cuid())
  orderId String @unique
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Stripe IDs
  stripePaymentIntentId   String  @unique
  stripeChargeId          String?
  stripeCheckoutSessionId String?
  stripeTransferId        String?
  stripeRefundId          String?

  // Amounts
  amount       Float
  currency     String @default("chf")
  platformFee  Float
  sellerAmount Float

  // Status tracking
  paymentStatus  String
  transferStatus String?
  refundStatus   String?

  // Webhook tracking
  lastWebhookEvent String?
  lastWebhookAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([stripePaymentIntentId])
  @@index([stripeChargeId])
  @@index([stripeTransferId])
  @@map("payment_records")
}

model PricingHistory {
  id                 String   @id @default(cuid())
  platformMarginRate Float?
  protectionFeeRate  Float? // Zahlungsschutz-Gebühr (z.B. 0.02 = 2%)
  vatRate            Float?
  minimumCommission  Float?
  maximumCommission  Float?
  listingFee         Float?
  transactionFee     Float?
  changedBy          String
  changedAt          DateTime @default(now())
  admin              User     @relation(fields: [changedBy], references: [id], onDelete: Cascade)

  @@index([changedAt])
  @@index([changedBy])
  @@map("pricing_history")
}

// Listing Drafts - Server-seitige Entwürfe für Verkaufsanzeigen
model Draft {
  id     String @id @default(cuid())
  userId String

  // Form data (JSON)
  formData String // JSON string mit allen Formularfeldern

  // Images (gespeichert in Blob Storage)
  images String? // JSON Array von Blob URLs (deprecated, use draftImages relation)

  // Cover/Title image reference
  coverImageId String? // FK to DraftImage.id

  // Metadata
  selectedCategory         String?
  selectedSubcategory      String?
  selectedBooster          String?
  paymentProtectionEnabled Boolean @default(false)
  currentStep              Int     @default(0)
  titleImageIndex          Int     @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  draftImages DraftImage[]

  @@index([userId])
  @@index([userId, updatedAt])
  @@index([createdAt])
  @@index([coverImageId])
  @@map("drafts")
}

// Draft Images - Persistierte Bilder für Entwürfe
model DraftImage {
  id         String   @id @default(cuid())
  draftId    String
  storageKey String   @unique // Path/key in storage bucket
  url        String // Public URL from blob storage
  sortOrder  Int      @default(0) // Optional: für Reihenfolge
  createdAt  DateTime @default(now())

  // Relations
  draft Draft @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@index([draftId])
  @@index([draftId, sortOrder])
  @@map("draft_images")
}

// ============================================
// PAYOUT / BANK DETAILS POLICY (Ricardo-like)
// ============================================

// Payout Profile - Stores encrypted IBAN and bank details for sellers
model PayoutProfile {
  id                String   @id @default(cuid())
  userId            String   @unique
  status            String   @default("UNSET") // 'UNSET' | 'ACTIVE' | 'CHANGE_REQUESTED' | 'SUSPENDED'
  accountHolderName String
  ibanEncrypted     String   // Encrypted IBAN (AES-256-GCM)
  ibanLast4         String   // Last 4 digits for display
  country           String   @default("CH")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  verifiedAt        DateTime?
  lockedReason      String?  // e.g. "Change requires approval"

  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  changeRequests    PayoutChangeRequest[]
  auditLogs         PayoutAuditLog[]

  @@index([userId])
  @@index([status])
  @@map("payout_profiles")
}

// Payout Change Requests - Tracks requests to change bank details
model PayoutChangeRequest {
  id                        String   @id @default(cuid())
  userId                    String
  requestedAccountHolderName String
  requestedIbanEncrypted     String   // Encrypted requested IBAN
  requestedIbanLast4         String   // Last 4 digits for display
  reason                    String?  // Optional reason for change
  status                    String   @default("PENDING") // 'PENDING' | 'APPROVED' | 'REJECTED' | 'CANCELLED'
  createdAt                 DateTime @default(now())
  decidedAt                 DateTime?
  decidedBy                 String?  // Admin user ID

  profile                   PayoutProfile @relation(fields: [userId], references: [userId], onDelete: Cascade)
  decider                   User?          @relation("PayoutChangeDecider", fields: [decidedBy], references: [id])

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("payout_change_requests")
}

// Payout Audit Log - Tracks all changes to payout profiles
model PayoutAuditLog {
  id          String   @id @default(cuid())
  userId      String
  action      String   // 'PROFILE_CREATED' | 'CHANGE_REQUESTED' | 'CHANGE_APPROVED' | 'CHANGE_REJECTED'
  metadata    String?  // JSON string with masked values, request id, etc.
  createdAt   DateTime @default(now())
  actorUserId String   // Who performed the action (user for own actions, admin for approvals)

  profile     PayoutProfile @relation(fields: [userId], references: [userId], onDelete: Cascade)
  actor       User          @relation("PayoutAuditActor", fields: [actorUserId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([action])
  @@map("payout_audit_logs")
}

// Stripe Webhook Events - Tracks processed webhook events for idempotency
model WebhookEvent {
  id           String   @id @default(cuid())
  stripeEventId String  @unique // Stripe Event ID (evt_xxx)
  eventType    String   // Event type (e.g., 'checkout.session.completed')
  orderId      String?  // Related order if applicable
  processedAt  DateTime @default(now())
  success      Boolean  @default(true)
  errorMessage String?  // Error message if processing failed

  @@index([stripeEventId])
  @@index([orderId])
  @@index([eventType])
  @@index([processedAt])
  @@map("webhook_events")
}

// Shipping Rate Catalog - Zentrale Preisliste für Versandoptionen (Ricardo-style)
model ShippingRateCatalog {
  id          String   @id @default(cuid())
  code        String   @unique // z.B. 'post_economy_2kg', 'addon_sperrgut'
  labelDe     String   // Deutsche Bezeichnung für UI
  basePriceChf Float   // Preis in CHF
  rateSetId   String   @default("default_ch_post") // Rate-Set Identifier (für zukünftige Erweiterungen)
  isAddon     Boolean  @default(false) // true für Add-ons (sperrgut, pickhome)
  addonType   String?  // 'sperrgut' | 'pickhome' | null
  service     String?  // 'economy' | 'priority' | null (nur für Base-Rates)
  weightTier  Int?     // 2 | 10 | 30 | null (nur für Base-Rates)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([rateSetId])
  @@index([code])
  @@index([isActive])
  @@index([isAddon])
  @@map("shipping_rate_catalog")
}
